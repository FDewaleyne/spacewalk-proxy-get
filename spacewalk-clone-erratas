#!/usr/bin/python

##
# To the extent possible under law, Red Hat, Inc. has dedicated all copyright to this software to the public domain worldwide, pursuant to the CC0 Public Domain Dedication. 
# This software is distributed without any warranty.  See <http://creativecommons.org/publicdomain/zero/1.0/>.
##
__author__ = "Felix Dewaleyne"
__credits__ = ["Felix Dewaleyne"]
__license__ = "GPL"
__version__ = "0.2"
__maintainer__ = "Felix Dewaleyne"
__email__ = "fdewaley@redhat.com"
__status__ = "test"

# offers to list all packages that are not signed with a specific key, tries to change them to a NVREA identical package of the right signature, when possible
# this script doesn't remove any package from the database, only from channels.

import xmlrpclib, warnings
URL=None
client=None
key=None
verbose=False

class RHNSConnection:

    username = None
    host = None
    key = None
    client = None
    closed = False

    def __init__(self,username,password,host):
        """connects to the satellite db with given parameters"""
        URL = "https://%s/rpc/api" % host
        self.client = xmlrpclib.Server(URL)
        self.key = client.auth.login(username,password)
        self.usernams = username
        self.host = host
        pass

    def close(self):
        """closes a connection. item can be destroyed then"""
        self.client.auth.logout(self.key)
        self.closed = True
        pass

    def __exit__(self):
        """closes connection on exit"""
        if not self.closed :
            self.client.auth.logout(self.key)
        pass


class RHNSErrata:

    packages=[]
    advisory_name=None
    advisory_synopsis=None
    issue_date=None

    def __init__(self,connection):
        """__init__ function, should populate the object with all the elements of the errata."""
        pass

    def __cmp__(self):
        """comparison function, tells if the items are the same or not."""
        pass


#the main function of the program
def main(version):
    import optparse
    global URL
    global client
    global key
    global verbose
    parser = optparse.OptionParser("Usage: %prog [options]\nThis program will clone all erratas from the source to the destination as long as they are not already present in the destiation",version=version)
    parser.add_option("-u", "--user", dest="user", type="string", help="User to connect to satellite")
    parser.add_option("-p", "--password", dest="password", type="string", help="Password to connect to satellite")
    parser.add_option("-c", "--destChannel", dest="destChannel", default=None, type="string", help="Label of the destination channel to parse. Must exist.")
    parser.add_option("-s", "--sourceChannel", dest="sourceChannel", default=None, type="string", help="Label of the source channel to clone from")
    parser.add_option("-H", "--host", dest="host", type="string", default="127.0.0.1", help="Satellite hostname or ip - defaults to %default")
    parser.add_option("-v", "--verbose", dest="verbose", action="store_true", default=False, help="Turns up the verbosity")
    parser.add_option("--listChannels", dest="listChannels", action="store_true", default=False, help="List all the channels")
    parser.add_option("--listErratas", dest="listErratas", action="store_true", default=False, help="Lists all the erratas of the source.")
    parser.add_option("--errataType", dest="errataType", default=None, type="string", help="The type of errata to display - one of 'Security Advisory', 'Product Enhancement Advisory', 'Bug Fix Advisory' ")
    parser.add_option("--maxIssueDate",dest="maxIssueDate", default=None, type="string", help="Maximum issue date for the erratas to be included (YYYY-MM-DD HH24:MI:SS)")
    parser.add_option("--minIssueDate",dest="minIssueDate", default=None, type="string", help="Minimum issue date for the erratas to be included (YYYY-MM-DD HH24:MI:SS)")
    (options, args) = parser.parse_args()
    verbose = options.verbose

    if not options.user or not  options.password:
        parser.error('username and password are required options.')
    else:
        #init
        co = RHNSConnection(options.user,options.password,options.host)
        if options.listChannels :
            print " %40s | %10s | %20s | %s " % ("Label", "Arch", "Provider", "Name")
            for channel in co.client.channel.listAllChannels(co.key):
                print " %40s | %10s | %20s | %s " % (channel['label'], channel['arch_name'],  channel['provider'], channel['name'])
        elif options.listErratas:
            if options.sourceChannel == None:
                parser.error('Need to specify the source channel when listing the erratas')
            else:
                print " %30s | %30s | %22s | %s" % ("Errata", "Type", "Update date", "Synopsis")
                #TODO: add support for filtering here
                for errata in co.client.channel.software.listErrata(co.key,options.sourceChannel):
                    print " %30s | %30s | %22s | %s" % (errata['advisory_name'], errata['advisory_type'], errata['issue_date'], errata['advisory_synopsis']) #warning may be depredicated with no actual replacement
        elif options.sourceChannel != None and options.destChannel != None:
            #TODO: determine which filters are in use and use appropriate functoin depending on which usecase.
            #TODO: step 1 get erratas to filter step 2 get all erratas from destination step 3 clone if not already in destination. only relevant packages, which are in the source, should be copied.
        else:
            parser.error("unable to determine what to do - use -h for usage information")

        client.auth.logout(key)

if __name__ == "__main__":
    main(__version__)

